<?php
/**
 * Created by PhpStorm.
 * User: User
 * Date: 020 20.01.17
 * Time: 10:33
 */

/**
 *                  Паттерн MVC
 * Пожалуй, главный паттерн - MVC - пожалуй самый применимый, в том числе и в ВЕБ программировании.
 * MVC - делит программу на 3 части:
 *
 * - MODEL (код, работающий с данными). Ее задача - дать нужные данные тем компонентам,
 * которые их запрашивают
 * Модель и только Модель, знает, где данные находятся, как они организованы. Что они лежат
 * в базе. что у базы есть пароль. Другим компонентам это знать не нужно.
 * Другие части ситемы только делают запросы к модели (вызывают методы).
 * Берут объект или класс вызывают его методы и этот объеке возвращает нужные данные.
 * Модель и только модель умеет обновлять, вставлять или удалять данные. CRUD
 * Модель ничего не выводит пользователю, модель никогда не работает напрямую с пользователем.
 * У модели есть только методы для CRUD
 * Модель часть программы - набор классов, объектов, может быть функций,
 * может конфигурационных файлов (что Вы логически выделяете в нечто-что Вы выделяете в Модель)
 * Данные не обязательно должна лежать в БД. Они могут лежать в файлах, приходить по API (Апи) от других приложений.
 * Вся работа с любыми данными это только модель!!!
 *
 * - VIEW (код формирущий представление) Формирует ответ на запрос клиента.
 * Например показывает полученные данные через шаблоны
 * В представлении и только в представлении мы используем HTML, CSS, JS (В других частях программы этого быть не должно)
 * Представление может содержать логику, нужную для вывода данных, и она может быть написана на PHP
 * Нормально смешивать PHP и HTML.
 *
 * - CONTROLLER - точка входа и логика приложения.
 * (код, обрабатывающий запрос от клиента и выполняющий бизнес логику приложения)
 * Контроллер принимает запрос от клиента (является точкой входа)
 * Только контролер работает с данными от пользователя (GEET, POST, FILES не должны просачиваться в Модель или Представление)
 * Получает нужные данные от моделей или дает моделям команды на модификацию данных
 * Обрабатывает эти данные в соответствии с бизнес-логикой.
 * Передает данные Представлению и инициирует ответ пользователю.
 * Контроллер и точка входа и некое связующее звено, объединяющее программу воедино.
 * Контроллер должен быть худой, тонкий. Его задача понять, что хочет пользователь и расскидать задания другим частям.
 *
 *
 * Построение системы моделей.
 * Начинаем программировать только при наличии определенных требований.
 * Первое, что нам нужно сделать - это собрать в одном классе всю работу с БД.
 * Логично сразу же запрограммировать класс DB, который должен удовлетворять следующим условиям:
 *   - Создает и инкапсулирует соединение с БД.
 *   - Умеет выполнять ЛЮБЫЕ запросы к БД. (желательно, чтобы это делал как можно проще).
 *   - Возвращает результаты запросов.
 *   - И данные.
 *   - И конечно обрабатывает ошибка.
 *
 * Репо https://github.com/pr-of-it/php2-lessons
 *      https://github.com/pr-of-it/php2-lessons-2016-10
 *      https://github.com/pr-of-it/PHP2-2017-01
 * 
 *      
 *      'foo\'bar'        экранирование   =>  foo'bar
 *      '\\'              экранирование   =>  \
 *
 *
 *                  ORM - Object Relational Mapping
 * Принцип отображения объектов реального мира (и их связей) на объекты вашего языка программирования
 * ООП прекрасно подходит для реализации этого шаблона проектирования.
 *   - Класс описывает какие объекты данных у нас могут быть.
 *   - Сами данные представлены объектами заданных классов.
 *   - И мы сразу можем определить "поведение данных" в виде методов этих объектов.
 *      class User {
 *          public $email;
 *          public $name;
 *      }
 *
 * Задача: "заставить" класс DB возвращать нам не просто данные в массивах, а объекты нужного нам класса! Это пригодится в дальнейшем.
 *
 * Талица в БД это класс. Объект это запись в таблице. Свойства объекта это поля записей.
 * 
 *
 *              Статические методы
 * Статические методы - это методы, которые принадлежат КЛАССУ в целом, а не конкретным объектам!
 * Это метод, который нельзя вызвать у объекта (у него нет this), он с объектом никак не связан.
 * Это метод который служит классу и работает с классом вцелом.
 * Стат методы пригождаются, когда нужно использовать какой-либо функционал, без создания объекта.
 * Для нашей текущей задачи было бы хорошо, чтобы класс USER самостоятельно искал нам нужные данные в БД.
 * Для решения этой задачи отлично подойдут статические методы.
 *      class User {
 *          public static $table = 'user';              // Стат свойство
 *
 *          public $email;
 *          public $name;
 *
 *          public static function findAll() {          // Стат метод
 *              ...
 *          }
 *      }
 *
 *      $users = \App\Models\User::findAll();;          // Вызываем метод без создания объекта
 *      echo \App\Models\User::$table;                  // Вызов стат метода класса User
 *      self::$table                                   // Обращение к свойству класса внутри самого класса
 *                                                      // self:: сам этот класс
 *
 *                  Константы
 * Часто бывает, что намв общем-то не нужно изменять некое значение, связанное с классом (напримеримя таблицы в модели).
 * В этом случае применяются константы.
 * Константы принадлежат классу, но в отличие от свойств они не могут изменяться.
 *      class User
 *      {
 *          const TABLE = 'users';          // Имя константы принят в ВЕРХНЕМ регистре
 *          ......
 *      }
 *
 *      echo Users::TABLE;                  Обращение к константе
 *
 * Свойство это просто переменное. Во время жизни класса мы можем перезаписать его значение, а констанет нет.
 * Константа определена один раз и навсегда. В ней может быть массив, число, строка (вещи могущие быть использованы без вычислений)
 * Константа всегда публична. ее нельзя сделать приватной.
 *
 *
 *
 *              Абстрактные классы   LSB 
 * В современном веб-приложении десятки объектов в БД (десятки таблиц), соответственно десятки классов моделей.
 * Будет хорошо выделить общие методы в общий условный класс.
 * Абстрактный класс - это класс, который не позволяет создание объектов этого класса.
 * Используются такие классы, конечно же, для наследования:
 *
 *              Раннее статическое связывание
 * В РНР self::   означает тот класс где self  написан
 * self Всегда связывается с тем классом, где оно написано.
 * Ранне потому что возникает на этапе компиляции кода, когда программа еще не выполняется.
 *
 *
 *              Позднее статическое связывание
 * Решение:
 *      echo self::$test;       // Было в родительском
 *      echo static::$test      // Меняем self на static
 *
 * static обозначет тот класс, который реально будет вызывать этот код.
 * слово static связывается с классом на позднем этапе, когда код уже выполняется.
 * Позднее стат связывание это слово static вместо self, которое связывается не с тем классом,
 *   где написано, а с тем откуда реально вызывается код.
 *
 *
 *              3 этапа исполнения программы
 * 1. Парсинг, когда наш текст превращается в синтактическое дерево.
 * 2. Компиляция, когда синтактическое дерево превращается в байт-код.
 * 3. Выполнение, когда байт-код выполняется на виртуальной машине.
 *
 *              Абстрактный метод
 *  В абстрактном классе могут содержаться методы с реализацией (с исполняемым кодом),
 *   а могут абстрактные методы
 *      abstract public function getName();
 * Это метод, который не содержит в себе кода и помечен словом abstract.
 * Это указание на то, что в наследнике этот метод должен быть обязательно реализован. (ТУ для наследника) иначе будет ошибка.
 *
 * Во всех других языках определени абстрактного класса звучало бы ""Это класс в котором есть абстрактный метод".
 * В РНР в абстрактном классе может не быть абстрактных методов, а просто сам класс помечен, как абстрактный.
 *
 *
 *
 *
 *
 *
 *
 *
 */